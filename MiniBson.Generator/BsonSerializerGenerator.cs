using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MiniBson.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class BsonSerializerGenerator : IIncrementalGenerator
{
    private const string BsonSerializableAttributeFullName = "MiniBson.BsonSerializableAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [BsonSerializable] attribute
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                BsonSerializableAttributeFullName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, ct) => GetContextClassInfo(ctx, ct))
            .Where(static info => info is not null)
            .Collect();

        context.RegisterSourceOutput(classDeclarations, GenerateCode);
    }

    private static ContextClassInfo? GetContextClassInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
            return null;

        var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;

        // Check if the class is partial
        if (!classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
            return null;

        // Collect all types from [BsonSerializable(typeof(...))] attributes
        var serializableTypes = new List<INamedTypeSymbol>();

        foreach (var attribute in classSymbol.GetAttributes())
        {
            if (attribute.AttributeClass?.ToDisplayString() != BsonSerializableAttributeFullName)
                continue;

            if (attribute.ConstructorArguments.Length > 0 &&
                attribute.ConstructorArguments[0].Value is INamedTypeSymbol typeSymbol)
            {
                serializableTypes.Add(typeSymbol);
            }
        }

        if (serializableTypes.Count == 0)
            return null;

        return new ContextClassInfo(
            classSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty,
            classSymbol.Name,
            GetAccessibility(classDeclaration),
            serializableTypes.ToImmutableArray());
    }

    private static string GetAccessibility(ClassDeclarationSyntax classDeclaration)
    {
        foreach (var modifier in classDeclaration.Modifiers)
        {
            switch (modifier.Kind())
            {
                case SyntaxKind.PublicKeyword:
                    return "public";
                case SyntaxKind.InternalKeyword:
                    return "internal";
                case SyntaxKind.PrivateKeyword:
                    return "private";
                case SyntaxKind.ProtectedKeyword:
                    return "protected";
            }
        }
        return "internal";
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<ContextClassInfo?> contextClasses)
    {
        foreach (var contextClass in contextClasses)
        {
            if (contextClass is null)
                continue;

            var source = GenerateContextClass(contextClass);
            context.AddSource($"{contextClass.ClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateContextClass(ContextClassInfo contextClass)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        sb.AppendLine("using System;");
        sb.AppendLine("using System.IO;");
        sb.AppendLine("using System.Collections;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using MiniBson;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(contextClass.Namespace))
        {
            sb.AppendLine($"namespace {contextClass.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"{contextClass.Accessibility} partial class {contextClass.ClassName}");
        sb.AppendLine("{");

        // Collect all types that need serialization (including nested types)
        var allTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        foreach (var type in contextClass.SerializableTypes)
        {
            CollectAllTypes(type, allTypes);
        }

        // Generate Write/Read methods for each type
        foreach (var type in allTypes)
        {
            GenerateWriteMethod(sb, type);
            sb.AppendLine();
            GenerateReadMethod(sb, type);
            sb.AppendLine();
        }

        // Generate public Serialize method
        GenerateSerializeMethod(sb, contextClass.SerializableTypes);
        sb.AppendLine();

        // Generate public Deserialize method
        GenerateDeserializeMethod(sb, contextClass.SerializableTypes);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void CollectAllTypes(ITypeSymbol type, HashSet<INamedTypeSymbol> allTypes)
    {
        var unwrapped = UnwrapType(type);
        if (unwrapped is not INamedTypeSymbol namedType)
            return;

        if (IsPrimitiveType(namedType))
            return;

        if (!allTypes.Add(namedType))
            return;

        // Collect types from properties
        foreach (var member in namedType.GetMembers())
        {
            if (member is IPropertySymbol property &&
                property.DeclaredAccessibility == Accessibility.Public &&
                !property.IsStatic &&
                property.GetMethod != null)
            {
                CollectAllTypes(property.Type, allTypes);
            }
        }
    }

    private static ITypeSymbol UnwrapType(ITypeSymbol type)
    {
        // Unwrap nullable
        if (type is INamedTypeSymbol { IsGenericType: true } namedType &&
            namedType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
        {
            return namedType.TypeArguments[0];
        }

        // Unwrap array
        if (type is IArrayTypeSymbol arrayType)
        {
            return arrayType.ElementType;
        }

        return type;
    }

    private static bool IsPrimitiveType(ITypeSymbol type)
    {
        // Enums are treated as primitives (mapped to their underlying type)
        if (type.TypeKind == TypeKind.Enum)
            return true;

        return type.SpecialType switch
        {
            SpecialType.System_Boolean => true,
            SpecialType.System_Byte => true,
            SpecialType.System_SByte => true,
            SpecialType.System_Int16 => true,
            SpecialType.System_UInt16 => true,
            SpecialType.System_Int32 => true,
            SpecialType.System_UInt32 => true,
            SpecialType.System_Int64 => true,
            SpecialType.System_UInt64 => true,
            SpecialType.System_Single => true,
            SpecialType.System_Double => true,
            SpecialType.System_String => true,
            SpecialType.System_DateTime => true,
            _ => type.ToDisplayString() == "System.Guid"
        };
    }

    private static bool IsNullableType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol { IsGenericType: true } namedType &&
            namedType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
        {
            return true;
        }

        return type.NullableAnnotation == NullableAnnotation.Annotated;
    }

    private static ITypeSymbol? GetEnumUnderlyingType(ITypeSymbol type)
    {
        if (type.TypeKind == TypeKind.Enum && type is INamedTypeSymbol namedType)
        {
            return namedType.EnumUnderlyingType;
        }
        return null;
    }

    private static ITypeSymbol GetUnderlyingNullableType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol { IsGenericType: true } namedType &&
            namedType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
        {
            return namedType.TypeArguments[0];
        }

        return type;
    }

    private static void GenerateWriteMethod(StringBuilder sb, INamedTypeSymbol type)
    {
        var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = GetSafeMethodName(type);

        sb.AppendLine($"    private void Write{methodName}(BsonWriter writer, {typeName} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");
        sb.AppendLine("        writer.WriteStartDocument();");

        // Get all properties including inherited ones
        foreach (var property in GetAllProperties(type))
        {
            GenerateWriteProperty(sb, property.Name, property.Type, $"instance.{property.Name}");
        }

        sb.AppendLine("        writer.WriteEndDocument();");
        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");
    }

    private static void GenerateWriteProperty(StringBuilder sb, string name, ITypeSymbol type, string accessor)
    {
        var isNullable = IsNullableType(type);
        var underlyingType = GetUnderlyingNullableType(type);

        if (isNullable && !type.IsValueType)
        {
            sb.AppendLine($"        if ({accessor} is null)");
            sb.AppendLine($"            writer.WriteNull(\"{name}\");");
            sb.AppendLine("        else");
            sb.AppendLine("        {");
            GenerateWriteValue(sb, name, underlyingType, accessor, "            ");
            sb.AppendLine("        }");
        }
        else if (isNullable && type.IsValueType)
        {
            sb.AppendLine($"        if ({accessor}.HasValue)");
            sb.AppendLine("        {");
            GenerateWriteValue(sb, name, underlyingType, $"{accessor}.Value", "            ");
            sb.AppendLine("        }");
            sb.AppendLine("        else");
            sb.AppendLine($"            writer.WriteNull(\"{name}\");");
        }
        else
        {
            GenerateWriteValue(sb, name, underlyingType, accessor, "        ");
        }
    }

    private static void GenerateWriteValue(StringBuilder sb, string name, ITypeSymbol type, string accessor, string indent)
    {
        // Handle byte[] as binary data
        if (type is IArrayTypeSymbol { ElementType.SpecialType: SpecialType.System_Byte })
        {
            sb.AppendLine($"{indent}writer.WriteBinary(\"{name}\", {accessor});");
            return;
        }

        // Handle arrays of enums
        if (type is IArrayTypeSymbol { ElementType.TypeKind: TypeKind.Enum } enumArrayType)
        {
            var elementType = enumArrayType.ElementType;
            sb.AppendLine($"{indent}writer.WriteStartArray(\"{name}\");");
            sb.AppendLine($"{indent}foreach (var item in {accessor})");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElement(sb, elementType, "item", indent + "    ");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}writer.WriteEndArray();");
            return;
        }

        // Handle other arrays
        if (type is IArrayTypeSymbol arrayType)
        {
            var elementType = arrayType.ElementType;
            sb.AppendLine($"{indent}writer.WriteStartArray(\"{name}\");");
            sb.AppendLine($"{indent}foreach (var item in {accessor})");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElement(sb, elementType, "item", indent + "    ");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}writer.WriteEndArray();");
            return;
        }

        // Handle enums - map to underlying type
        var enumUnderlying = GetEnumUnderlyingType(type);
        if (enumUnderlying != null)
        {
            var underlyingSpecial = enumUnderlying.SpecialType;
            if (underlyingSpecial == SpecialType.System_Int64 || underlyingSpecial == SpecialType.System_UInt64 || underlyingSpecial == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}writer.WriteInt64(\"{name}\", (long){accessor});");
            }
            else
            {
                sb.AppendLine($"{indent}writer.WriteInt32(\"{name}\", (int){accessor});");
            }
            return;
        }

        // Handle primitives
        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}writer.WriteBoolean(\"{name}\", {accessor});");
                return;
            case SpecialType.System_Int32:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_Int16:
            case SpecialType.System_UInt16:
                sb.AppendLine($"{indent}writer.WriteInt32(\"{name}\", {accessor});");
                return;
            case SpecialType.System_Int64:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                sb.AppendLine($"{indent}writer.WriteInt64(\"{name}\", (long){accessor});");
                return;
            case SpecialType.System_Single:
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}writer.WriteDouble(\"{name}\", {accessor});");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}writer.WriteString(\"{name}\", {accessor});");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}writer.WriteDateTime(\"{name}\", {accessor});");
                return;
        }

        // Handle Guid
        if (type.ToDisplayString() == "System.Guid")
        {
            sb.AppendLine($"{indent}writer.WriteGuid(\"{name}\", {accessor});");
            return;
        }

        // Handle nested objects (but not primitives)
        if (type is INamedTypeSymbol namedType && !IsPrimitiveType(namedType))
        {
            var methodName = GetSafeMethodName(namedType);
            sb.AppendLine($"{indent}writer.WriteStartDocument(\"{name}\");");
            sb.AppendLine($"{indent}Write{methodName}Inner(writer, {accessor});");
            sb.AppendLine($"{indent}writer.WriteEndDocument();");
        }
    }

    private static void GenerateWriteArrayElement(StringBuilder sb, ITypeSymbol type, string accessor, string indent)
    {
        var isNullable = IsNullableType(type);
        var underlyingType = GetUnderlyingNullableType(type);

        if (isNullable && !type.IsValueType)
        {
            sb.AppendLine($"{indent}if ({accessor} is null)");
            sb.AppendLine($"{indent}    writer.WriteNull();");
            sb.AppendLine($"{indent}else");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElementValue(sb, underlyingType, accessor, indent + "    ");
            sb.AppendLine($"{indent}}}");
        }
        else if (isNullable && type.IsValueType)
        {
            sb.AppendLine($"{indent}if ({accessor}.HasValue)");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElementValue(sb, underlyingType, $"{accessor}.Value", indent + "    ");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}else");
            sb.AppendLine($"{indent}    writer.WriteNull();");
        }
        else
        {
            GenerateWriteArrayElementValue(sb, underlyingType, accessor, indent);
        }
    }

    private static void GenerateWriteArrayElementValue(StringBuilder sb, ITypeSymbol type, string accessor, string indent)
    {
        // Handle enums - map to underlying type
        var enumUnderlying = GetEnumUnderlyingType(type);
        if (enumUnderlying != null)
        {
            var underlyingSpecial = enumUnderlying.SpecialType;
            if (underlyingSpecial == SpecialType.System_Int64 || underlyingSpecial == SpecialType.System_UInt64 || underlyingSpecial == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}writer.WriteInt64((long){accessor});");
            }
            else
            {
                sb.AppendLine($"{indent}writer.WriteInt32((int){accessor});");
            }
            return;
        }

        // Handle primitives (array element versions without name)
        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}writer.WriteBoolean({accessor});");
                return;
            case SpecialType.System_Int32:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_Int16:
            case SpecialType.System_UInt16:
                sb.AppendLine($"{indent}writer.WriteInt32({accessor});");
                return;
            case SpecialType.System_Int64:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                sb.AppendLine($"{indent}writer.WriteInt64((long){accessor});");
                return;
            case SpecialType.System_Single:
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}writer.WriteDouble({accessor});");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}writer.WriteString({accessor});");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}writer.WriteDateTime({accessor});");
                return;
        }

        // Handle nested objects in array (but not primitives)
        if (type is INamedTypeSymbol namedType && !IsPrimitiveType(namedType))
        {
            var methodName = GetSafeMethodName(namedType);
            sb.AppendLine($"{indent}writer.WriteStartNestedDocument();");
            sb.AppendLine($"{indent}Write{methodName}Inner(writer, {accessor});");
            sb.AppendLine($"{indent}writer.WriteEndDocument();");
        }
    }

    private static void GenerateReadMethod(StringBuilder sb, INamedTypeSymbol type)
    {
        var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = GetSafeMethodName(type);

        sb.AppendLine($"    private {typeName}? Read{methodName}(BsonReader reader)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");
        sb.AppendLine("        reader.ReadStartDocument();");
        sb.AppendLine($"        var result = Read{methodName}Inner(reader);");
        sb.AppendLine("        reader.ReadEndDocument();");
        sb.AppendLine("        return result;");
        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate inner read method (without ReadStartDocument/ReadEndDocument)
        sb.AppendLine($"    private {typeName} Read{methodName}Inner(BsonReader reader)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");

        // Declare variables for all properties including inherited
        foreach (var property in GetAllProperties(type))
        {
            var propertyType = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var defaultValue = GetDefaultValue(property.Type);
            sb.AppendLine($"        {propertyType} _{property.Name} = {defaultValue};");
        }

        sb.AppendLine();
        sb.AppendLine("        while (reader.Read())");
        sb.AppendLine("        {");
        sb.AppendLine("            switch (reader.CurrentName)");
        sb.AppendLine("            {");

        foreach (var property in GetAllProperties(type))
        {
            sb.AppendLine($"                case \"{property.Name}\":");
            GenerateReadProperty(sb, property.Name, property.Type, "                    ");
            sb.AppendLine("                    break;");
        }

        sb.AppendLine("                default:");
        sb.AppendLine("                    reader.Skip();");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Create and return the object
        sb.AppendLine($"        return new {typeName}");
        sb.AppendLine("        {");

        var first = true;
        foreach (var property in GetAllProperties(type))
        {
            if (!first)
                sb.AppendLine(",");
            else
                first = false;

            sb.Append($"            {property.Name} = _{property.Name}");
        }

        sb.AppendLine();
        sb.AppendLine("        };");
        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");

        // Generate inner write method (without WriteStartDocument/WriteEndDocument)
        sb.AppendLine();
        sb.AppendLine($"    private void Write{methodName}Inner(BsonWriter writer, {typeName} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");

        foreach (var property in GetAllProperties(type))
        {

            GenerateWriteProperty(sb, property.Name, property.Type, $"instance.{property.Name}");
        }

        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");
    }

    private static string GetDefaultValue(ITypeSymbol type)
    {
        if (IsNullableType(type) || !type.IsValueType)
            return "default!";

        return type.SpecialType switch
        {
            SpecialType.System_Boolean => "false",
            SpecialType.System_Int32 => "0",
            SpecialType.System_Int64 => "0L",
            SpecialType.System_Double => "0.0",
            SpecialType.System_Single => "0.0f",
            SpecialType.System_String => "string.Empty",
            _ => "default!"
        };
    }

    private static void GenerateReadProperty(StringBuilder sb, string name, ITypeSymbol type, string indent)
    {
        var isNullable = IsNullableType(type);
        var underlyingType = GetUnderlyingNullableType(type);

        sb.AppendLine($"{indent}if (reader.CurrentType == BsonType.Null)");
        sb.AppendLine($"{indent}    _{name} = default;");
        sb.AppendLine($"{indent}else");

        // Handle byte[] as binary data
        if (type is IArrayTypeSymbol { ElementType.SpecialType: SpecialType.System_Byte })
        {
            sb.AppendLine($"{indent}    _{name} = reader.ReadBinary().Data;");
        }
        else if (type is IArrayTypeSymbol arrayType)
        {
            GenerateReadArray(sb, name, arrayType, indent + "    ");
        }
        else
        {
            GenerateReadValue(sb, name, underlyingType, indent + "    ");
        }
    }

    private static void GenerateReadArray(StringBuilder sb, string name, IArrayTypeSymbol arrayType, string indent)
    {
        var elementType = arrayType.ElementType;
        var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    var list = new global::System.Collections.Generic.List<{elementTypeName}>();");
        sb.AppendLine($"{indent}    reader.ReadStartArray();");
        sb.AppendLine($"{indent}    while (reader.Read())");
        sb.AppendLine($"{indent}    {{");

        var isElementNullable = IsNullableType(elementType);
        var underlyingElementType = GetUnderlyingNullableType(elementType);

        if (isElementNullable || !elementType.IsValueType)
        {
            sb.AppendLine($"{indent}        if (reader.CurrentType == BsonType.Null)");
            sb.AppendLine($"{indent}            list.Add(default!);");
            sb.AppendLine($"{indent}        else");
            GenerateReadArrayElement(sb, underlyingElementType, indent + "            ");
        }
        else
        {
            GenerateReadArrayElement(sb, underlyingElementType, indent + "        ");
        }

        sb.AppendLine($"{indent}    }}");
        sb.AppendLine($"{indent}    reader.ReadEndDocument();");
        sb.AppendLine($"{indent}    _{name} = list.ToArray();");
        sb.AppendLine($"{indent}}}");
    }

    private static void GenerateReadArrayElement(StringBuilder sb, ITypeSymbol type, string indent)
    {
        // Handle enums - read as underlying type and cast
        var enumUnderlying = GetEnumUnderlyingType(type);
        if (enumUnderlying != null)
        {
            var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var underlyingSpecial = enumUnderlying.SpecialType;
            if (underlyingSpecial == SpecialType.System_Int64 || underlyingSpecial == SpecialType.System_UInt64 || underlyingSpecial == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}list.Add(({typeName})reader.ReadInt64());");
            }
            else
            {
                sb.AppendLine($"{indent}list.Add(({typeName})reader.ReadInt32());");
            }
            return;
        }

        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}list.Add(reader.ReadBoolean());");
                return;
            case SpecialType.System_Int32:
                sb.AppendLine($"{indent}list.Add(reader.ReadInt32());");
                return;
            case SpecialType.System_Int64:
                sb.AppendLine($"{indent}list.Add(reader.ReadInt64());");
                return;
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}list.Add(reader.ReadDouble());");
                return;
            case SpecialType.System_Single:
                sb.AppendLine($"{indent}list.Add((float)reader.ReadDouble());");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}list.Add(reader.ReadString());");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}list.Add(reader.ReadDateTime());");
                return;
        }

        if (type.ToDisplayString() == "System.Guid")
        {
            sb.AppendLine($"{indent}list.Add(reader.ReadGuid());");
            return;
        }

        // Nested object (but not primitives)
        if (type is INamedTypeSymbol namedType && !IsPrimitiveType(namedType))
        {
            var methodName = GetSafeMethodName(namedType);
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    reader.ReadStartNestedDocument();");
            sb.AppendLine($"{indent}    list.Add(Read{methodName}Inner(reader));");
            sb.AppendLine($"{indent}    reader.ReadEndDocument();");
            sb.AppendLine($"{indent}}}");
        }
    }

    private static void GenerateReadValue(StringBuilder sb, string name, ITypeSymbol type, string indent)
    {
        // Handle enums - read as underlying type and cast
        var enumUnderlying = GetEnumUnderlyingType(type);
        if (enumUnderlying != null)
        {
            var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var underlyingSpecial = enumUnderlying.SpecialType;
            if (underlyingSpecial == SpecialType.System_Int64 || underlyingSpecial == SpecialType.System_UInt64 || underlyingSpecial == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}_{name} = ({typeName})reader.ReadInt64();");
            }
            else
            {
                sb.AppendLine($"{indent}_{name} = ({typeName})reader.ReadInt32();");
            }
            return;
        }

        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}_{name} = reader.ReadBoolean();");
                return;
            case SpecialType.System_Int32:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_Int16:
            case SpecialType.System_UInt16:
                sb.AppendLine($"{indent}_{name} = reader.ReadInt32();");
                return;
            case SpecialType.System_Int64:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                sb.AppendLine($"{indent}_{name} = reader.ReadInt64();");
                return;
            case SpecialType.System_Single:
                sb.AppendLine($"{indent}_{name} = (float)reader.ReadDouble();");
                return;
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}_{name} = reader.ReadDouble();");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}_{name} = reader.ReadString();");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}_{name} = reader.ReadDateTime();");
                return;
        }

        if (type.ToDisplayString() == "System.Guid")
        {
            sb.AppendLine($"{indent}_{name} = reader.ReadGuid();");
            return;
        }

        // Nested object (but not primitives)
        if (type is INamedTypeSymbol namedType && !IsPrimitiveType(namedType))
        {
            var methodName = GetSafeMethodName(namedType);
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    reader.ReadStartNestedDocument();");
            sb.AppendLine($"{indent}    _{name} = Read{methodName}Inner(reader);");
            sb.AppendLine($"{indent}    reader.ReadEndDocument();");
            sb.AppendLine($"{indent}}}");
        }
    }

    private static void GenerateSerializeMethod(StringBuilder sb, ImmutableArray<INamedTypeSymbol> types)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Serializes the specified object to BSON format.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public void Serialize(object input, Stream output)");
        sb.AppendLine("    {");
        sb.AppendLine("        using var writer = new BsonWriter(output, leaveOpen: true);");
        sb.AppendLine("        var inputType = input.GetType();");

        var first = true;
        foreach (var type in types)
        {
            var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var methodName = GetSafeMethodName(type);
            
            if (first)
            {
                sb.AppendLine($"        if (inputType == typeof({typeName}))");
                first = false;
            }
            else
            {
                sb.AppendLine($"        else if (inputType == typeof({typeName}))");
            }
            
            sb.AppendLine($"            Write{methodName}(writer, ({typeName})input);");
        }

        sb.AppendLine("        else");
        sb.AppendLine("            throw new NotSupportedException($\"Type {input.GetType()} is not supported for serialization.\");");
        sb.AppendLine("    }");
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, ImmutableArray<INamedTypeSymbol> types)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Deserializes BSON data to an object of the specified type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public object? Deserialize(Stream input, Type type)");
        sb.AppendLine("    {");
        sb.AppendLine("        using var reader = new BsonReader(input, leaveOpen: true);");

        var first = true;
        foreach (var type in types)
        {
            var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var methodName = GetSafeMethodName(type);

            if (first)
            {
                sb.AppendLine($"        if (type == typeof({typeName}))");
                first = false;
            }
            else
            {
                sb.AppendLine($"        else if (type == typeof({typeName}))");
            }

            sb.AppendLine($"            return Read{methodName}(reader);");
        }

        sb.AppendLine();
        sb.AppendLine("        throw new NotSupportedException($\"Type {type} is not supported for deserialization.\");");
        sb.AppendLine("    }");
    }

    private static IEnumerable<IPropertySymbol> GetAllProperties(INamedTypeSymbol type)
    {
        // Collect types from derived to base
        var typeHierarchy = new List<INamedTypeSymbol>();
        var currentType = type;
        
        while (currentType != null && currentType.SpecialType != SpecialType.System_Object)
        {
            typeHierarchy.Add(currentType);
            currentType = currentType.BaseType;
        }
        
        // Reverse to get base-to-derived order
        typeHierarchy.Reverse();
        
        // Collect properties in base-to-derived order
        var properties = new List<IPropertySymbol>();
        var seenPropertyNames = new HashSet<string>();
        
        foreach (var typeInHierarchy in typeHierarchy)
        {
            foreach (var member in typeInHierarchy.GetMembers())
            {
                if (member is IPropertySymbol property &&
                    property.DeclaredAccessibility == Accessibility.Public &&
                    !property.IsStatic &&
                    property.GetMethod != null)
                {
                    // Only add if not already added (handles property hiding/new)
                    if (seenPropertyNames.Add(property.Name))
                    {
                        properties.Add(property);
                    }
                }
            }
        }
        
        return properties;
    }

    private static string GetSafeMethodName(INamedTypeSymbol type)
    {
        // Create a safe method name from the type name
        return type.Name.Replace(".", "_").Replace("+", "_");
    }

    private sealed class ContextClassInfo
    {
        public string Namespace { get; }
        public string ClassName { get; }
        public string Accessibility { get; }
        public ImmutableArray<INamedTypeSymbol> SerializableTypes { get; }

        public ContextClassInfo(
            string ns,
            string className,
            string accessibility,
            ImmutableArray<INamedTypeSymbol> serializableTypes)
        {
            Namespace = ns;
            ClassName = className;
            Accessibility = accessibility;
            SerializableTypes = serializableTypes;
        }
    }
}


