using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MiniBson.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class BsonSerializerGenerator : IIncrementalGenerator
{
    private const string BsonSerializableAttributeFullName = "MiniBson.BsonSerializableAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [BsonSerializable] attribute
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                BsonSerializableAttributeFullName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, ct) => GetContextClassInfo(ctx, ct))
            .Where(static info => info is not null)
            .Collect();

        context.RegisterSourceOutput(classDeclarations, GenerateCode);
    }

    private static ContextClassInfo? GetContextClassInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
            return null;

        var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;

        // Check if the class is partial
        if (!classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
            return null;

        // Collect all types from [BsonSerializable(typeof(...))] attributes
        var serializableTypes = new List<TypeInfo>();

        foreach (var attribute in classSymbol.GetAttributes())
        {
            if (attribute.AttributeClass?.ToDisplayString() != BsonSerializableAttributeFullName)
                continue;

            if (attribute.ConstructorArguments.Length > 0 &&
                attribute.ConstructorArguments[0].Value is INamedTypeSymbol typeSymbol)
            {
                serializableTypes.Add(ExtractTypeInfo(typeSymbol));
            }
        }

        if (serializableTypes.Count == 0)
            return null;

        return new ContextClassInfo(
            classSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty,
            classSymbol.Name,
            GetAccessibility(classDeclaration),
            new EquatableList<TypeInfo>(serializableTypes));
    }

    private static string GetAccessibility(ClassDeclarationSyntax classDeclaration)
    {
        foreach (var modifier in classDeclaration.Modifiers)
        {
            switch (modifier.Kind())
            {
                case SyntaxKind.PublicKeyword:
                    return "public";
                case SyntaxKind.InternalKeyword:
                    return "internal";
                case SyntaxKind.PrivateKeyword:
                    return "private";
                case SyntaxKind.ProtectedKeyword:
                    return "protected";
            }
        }
        return "internal";
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<ContextClassInfo?> contextClasses)
    {
        foreach (var contextClass in contextClasses)
        {
            if (contextClass is not { } ctx)
                continue;

            var source = GenerateContextClass(ctx);
            context.AddSource($"{ctx.ClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateContextClass(ContextClassInfo contextClass)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        sb.AppendLine("using System;");
        sb.AppendLine("using System.IO;");
        sb.AppendLine("using System.Collections;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using MiniBson;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(contextClass.Namespace))
        {
            sb.AppendLine($"namespace {contextClass.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"{contextClass.Accessibility} partial class {contextClass.ClassName}");
        sb.AppendLine("{");

        // Collect all types that need serialization (including nested types)
        var allTypes = new Dictionary<string, TypeInfo>();
        foreach (var type in contextClass.SerializableTypes)
        {
            CollectAllTypes(type, allTypes);
        }

        // Generate Write/Read methods for each type
        foreach (var type in allTypes.Values)
        {
            GenerateWriteMethod(sb, type);
            sb.AppendLine();
            GenerateReadMethod(sb, type);
            sb.AppendLine();
        }

        // Generate public Serialize method
        GenerateSerializeMethod(sb, contextClass.SerializableTypes);
        sb.AppendLine();

        // Generate public Deserialize method
        GenerateDeserializeMethod(sb, contextClass.SerializableTypes);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void CollectAllTypes(TypeInfo type, Dictionary<string, TypeInfo> allTypes)
    {
        if (allTypes.ContainsKey(type.FullyQualifiedName))
            return;

        allTypes[type.FullyQualifiedName] = type;

        // Collect types from properties
        foreach (var property in type.Properties)
        {
            CollectAllTypesFromRef(property.Type, allTypes);
        }
    }

    private static void CollectAllTypesFromRef(TypeRefInfo typeRef, Dictionary<string, TypeInfo> allTypes)
    {
        if (typeRef.NestedTypeInfo is { } nested)
        {
            CollectAllTypes(nested, allTypes);
        }

        if (typeRef.ArrayElementType is { } arrayElement)
        {
            CollectAllTypesFromRef(arrayElement, allTypes);
        }

        if (typeRef.NullableUnderlyingType is { } nullableUnderlying)
        {
            CollectAllTypesFromRef(nullableUnderlying, allTypes);
        }
    }

    private static bool IsPrimitiveType(ITypeSymbol type)
    {
        // Enums are treated as primitives (mapped to their underlying type)
        if (type.TypeKind == TypeKind.Enum)
            return true;

        return type.SpecialType switch
        {
            SpecialType.System_Boolean => true,
            SpecialType.System_Byte => true,
            SpecialType.System_SByte => true,
            SpecialType.System_Int16 => true,
            SpecialType.System_UInt16 => true,
            SpecialType.System_Int32 => true,
            SpecialType.System_UInt32 => true,
            SpecialType.System_Int64 => true,
            SpecialType.System_UInt64 => true,
            SpecialType.System_Single => true,
            SpecialType.System_Double => true,
            SpecialType.System_String => true,
            SpecialType.System_DateTime => true,
            _ => type.ToDisplayString() == "System.Guid"
        };
    }

    private static void GenerateWriteMethod(StringBuilder sb, TypeInfo type)
    {
        var typeName = type.FullyQualifiedName;
        var methodName = GetSafeMethodName(type);

        sb.AppendLine($"    private void Write{methodName}(BsonWriter writer, {typeName} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");
        sb.AppendLine("        writer.WriteStartDocument();");

        // Get all properties including inherited ones
        foreach (var property in type.Properties)
        {
            GenerateWriteProperty(sb, property.Name, property.Type, $"instance.{property.Name}");
        }

        sb.AppendLine("        writer.WriteEndDocument();");
        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");
    }

    private static void GenerateWriteProperty(StringBuilder sb, string name, TypeRefInfo type, string accessor)
    {
        var isNullable = type.IsNullable;
        var underlyingType = type.NullableUnderlyingType ?? type;

        if (isNullable && !type.IsValueType)
        {
            sb.AppendLine($"        if ({accessor} is null)");
            sb.AppendLine($"            writer.WriteNull(\"{name}\");");
            sb.AppendLine("        else");
            sb.AppendLine("        {");
            GenerateWriteValue(sb, name, underlyingType, accessor, "            ");
            sb.AppendLine("        }");
        }
        else if (isNullable && type.IsValueType)
        {
            sb.AppendLine($"        if ({accessor}.HasValue)");
            sb.AppendLine("        {");
            GenerateWriteValue(sb, name, underlyingType, $"{accessor}.Value", "            ");
            sb.AppendLine("        }");
            sb.AppendLine("        else");
            sb.AppendLine($"            writer.WriteNull(\"{name}\");");
        }
        else
        {
            GenerateWriteValue(sb, name, underlyingType, accessor, "        ");
        }
    }

    private static void GenerateWriteValue(StringBuilder sb, string name, TypeRefInfo type, string accessor, string indent)
    {
        // Handle byte[] as binary data
        if (type.ArrayElementType is { SpecialType: SpecialType.System_Byte })
        {
            sb.AppendLine($"{indent}writer.WriteBinary(\"{name}\", {accessor});");
            return;
        }

        // Handle arrays of enums
        if (type.ArrayElementType is { TypeKind: TypeKind.Enum } enumArrayElementType)
        {
            sb.AppendLine($"{indent}writer.WriteStartArray(\"{name}\");");
            sb.AppendLine($"{indent}foreach (var item in {accessor})");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElement(sb, enumArrayElementType, "item", indent + "    ");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}writer.WriteEndArray();");
            return;
        }

        // Handle other arrays
        if (type.ArrayElementType is { } arrayElementType)
        {
            sb.AppendLine($"{indent}writer.WriteStartArray(\"{name}\");");
            sb.AppendLine($"{indent}foreach (var item in {accessor})");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElement(sb, arrayElementType, "item", indent + "    ");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}writer.WriteEndArray();");
            return;
        }

        // Handle enums - map to underlying type
        if (type.EnumUnderlyingType is { } enumUnderlying)
        {
            if (enumUnderlying == SpecialType.System_Int64 || enumUnderlying == SpecialType.System_UInt64 || enumUnderlying == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}writer.WriteInt64(\"{name}\", (long){accessor});");
            }
            else
            {
                sb.AppendLine($"{indent}writer.WriteInt32(\"{name}\", (int){accessor});");
            }
            return;
        }

        // Handle primitives
        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}writer.WriteBoolean(\"{name}\", {accessor});");
                return;
            case SpecialType.System_Int32:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_Int16:
            case SpecialType.System_UInt16:
                sb.AppendLine($"{indent}writer.WriteInt32(\"{name}\", {accessor});");
                return;
            case SpecialType.System_Int64:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                sb.AppendLine($"{indent}writer.WriteInt64(\"{name}\", (long){accessor});");
                return;
            case SpecialType.System_Single:
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}writer.WriteDouble(\"{name}\", {accessor});");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}writer.WriteString(\"{name}\", {accessor});");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}writer.WriteDateTime(\"{name}\", {accessor});");
                return;
        }

        // Handle Guid
        if (type.FullyQualifiedName == "global::System.Guid" || type.Name == "Guid")
        {
            sb.AppendLine($"{indent}writer.WriteGuid(\"{name}\", {accessor});");
            return;
        }

        // Handle nested objects (but not primitives)
        if (type.NestedTypeInfo is { } nestedType)
        {
            var methodName = GetSafeMethodName(nestedType);
            sb.AppendLine($"{indent}writer.WriteStartDocument(\"{name}\");");
            sb.AppendLine($"{indent}Write{methodName}Inner(writer, {accessor});");
            sb.AppendLine($"{indent}writer.WriteEndDocument();");
        }
    }

    private static void GenerateWriteArrayElement(StringBuilder sb, TypeRefInfo type, string accessor, string indent)
    {
        var isNullable = type.IsNullable;
        var underlyingType = type.NullableUnderlyingType ?? type;

        if (isNullable && !type.IsValueType)
        {
            sb.AppendLine($"{indent}if ({accessor} is null)");
            sb.AppendLine($"{indent}    writer.WriteNull();");
            sb.AppendLine($"{indent}else");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElementValue(sb, underlyingType, accessor, indent + "    ");
            sb.AppendLine($"{indent}}}");
        }
        else if (isNullable && type.IsValueType)
        {
            sb.AppendLine($"{indent}if ({accessor}.HasValue)");
            sb.AppendLine($"{indent}{{");
            GenerateWriteArrayElementValue(sb, underlyingType, $"{accessor}.Value", indent + "    ");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}else");
            sb.AppendLine($"{indent}    writer.WriteNull();");
        }
        else
        {
            GenerateWriteArrayElementValue(sb, underlyingType, accessor, indent);
        }
    }

    private static void GenerateWriteArrayElementValue(StringBuilder sb, TypeRefInfo type, string accessor, string indent)
    {
        // Handle enums - map to underlying type
        if (type.EnumUnderlyingType is { } enumUnderlying)
        {
            if (enumUnderlying == SpecialType.System_Int64 || enumUnderlying == SpecialType.System_UInt64 || enumUnderlying == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}writer.WriteInt64((long){accessor});");
            }
            else
            {
                sb.AppendLine($"{indent}writer.WriteInt32((int){accessor});");
            }
            return;
        }

        // Handle primitives (array element versions without name)
        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}writer.WriteBoolean({accessor});");
                return;
            case SpecialType.System_Int32:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_Int16:
            case SpecialType.System_UInt16:
                sb.AppendLine($"{indent}writer.WriteInt32({accessor});");
                return;
            case SpecialType.System_Int64:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                sb.AppendLine($"{indent}writer.WriteInt64((long){accessor});");
                return;
            case SpecialType.System_Single:
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}writer.WriteDouble({accessor});");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}writer.WriteString({accessor});");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}writer.WriteDateTime({accessor});");
                return;
        }

        // Handle nested objects in array (but not primitives)
        if (type.NestedTypeInfo is { } nestedType)
        {
            var methodName = GetSafeMethodName(nestedType);
            sb.AppendLine($"{indent}writer.WriteStartNestedDocument();");
            sb.AppendLine($"{indent}Write{methodName}Inner(writer, {accessor});");
            sb.AppendLine($"{indent}writer.WriteEndDocument();");
        }
    }

    private static void GenerateReadMethod(StringBuilder sb, TypeInfo type)
    {
        var typeName = type.FullyQualifiedName;
        var methodName = GetSafeMethodName(type);

        sb.AppendLine($"    private {typeName}? Read{methodName}(BsonReader reader)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");
        sb.AppendLine("        reader.ReadStartDocument();");
        sb.AppendLine($"        var result = Read{methodName}Inner(reader);");
        sb.AppendLine("        reader.ReadEndDocument();");
        sb.AppendLine("        return result;");
        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate inner read method (without ReadStartDocument/ReadEndDocument)
        sb.AppendLine($"    private {typeName} Read{methodName}Inner(BsonReader reader)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");

        // Declare variables for all properties including inherited
        foreach (var property in type.Properties)
        {
            var propertyType = property.Type.FullyQualifiedName;
            var defaultValue = GetDefaultValue(property.Type);
            sb.AppendLine($"        {propertyType} _{property.Name} = {defaultValue};");
        }

        sb.AppendLine();
        sb.AppendLine("        while (reader.Read())");
        sb.AppendLine("        {");
        sb.AppendLine("            switch (reader.CurrentName)");
        sb.AppendLine("            {");

        foreach (var property in type.Properties)
        {
            sb.AppendLine($"                case \"{property.Name}\":");
            GenerateReadProperty(sb, property.Name, property.Type, "                    ");
            sb.AppendLine("                    break;");
        }

        sb.AppendLine("                default:");
        sb.AppendLine("                    reader.Skip();");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Create and return the object
        var properties = type.Properties.ToList();
        
        // Check if type is a record
        var isRecord = type.IsRecord;

        if (isRecord)
        {
            // Use constructor for records
            sb.AppendLine($"        return new {typeName}(");
            var first = true;
            foreach (var property in properties)
            {
                if (!first)
                    sb.AppendLine(",");
                else
                    first = false;

                sb.Append($"            _{property.Name}");
            }
            sb.AppendLine();
            sb.AppendLine("        );");
        }
        else
        {
            // Use object initializer for classes
            sb.AppendLine($"        return new {typeName}");
            sb.AppendLine("        {");

            var first = true;
            foreach (var property in properties)
            {
                if (!first)
                    sb.AppendLine(",");
                else
                    first = false;

                sb.Append($"            {property.Name} = _{property.Name}");
            }

            sb.AppendLine();
            sb.AppendLine("        };");
        }
        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");

        // Generate inner write method (without WriteStartDocument/WriteEndDocument)
        sb.AppendLine();
        sb.AppendLine($"    private void Write{methodName}Inner(BsonWriter writer, {typeName} instance)");
        sb.AppendLine("    {");
        sb.AppendLine("#nullable disable");

        foreach (var property in type.Properties)
        {

            GenerateWriteProperty(sb, property.Name, property.Type, $"instance.{property.Name}");
        }

        sb.AppendLine("#nullable restore");
        sb.AppendLine("    }");
    }

    private static string GetDefaultValue(TypeRefInfo type)
    {
        if (type.IsNullable || !type.IsValueType)
            return "default!";

        return type.SpecialType switch
        {
            SpecialType.System_Boolean => "false",
            SpecialType.System_Int32 => "0",
            SpecialType.System_Int64 => "0L",
            SpecialType.System_Double => "0.0",
            SpecialType.System_Single => "0.0f",
            SpecialType.System_String => "string.Empty",
            _ => "default!"
        };
    }

    private static void GenerateReadProperty(StringBuilder sb, string name, TypeRefInfo type, string indent)
    {
        var underlyingType = type.NullableUnderlyingType ?? type;

        sb.AppendLine($"{indent}if (reader.CurrentType == BsonType.Null)");
        sb.AppendLine($"{indent}    _{name} = default;");
        sb.AppendLine($"{indent}else");

        // Handle byte[] as binary data
        if (type.ArrayElementType is { SpecialType: SpecialType.System_Byte })
        {
            sb.AppendLine($"{indent}    _{name} = reader.ReadBinary().Data;");
        }
        else if (type.ArrayElementType is { } arrayElementType)
        {
            GenerateReadArray(sb, name, arrayElementType, indent + "    ");
        }
        else
        {
            GenerateReadValue(sb, name, underlyingType, indent + "    ");
        }
    }

    private static void GenerateReadArray(StringBuilder sb, string name, TypeRefInfo elementType, string indent)
    {
        var elementTypeName = elementType.FullyQualifiedName;

        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    var list = new global::System.Collections.Generic.List<{elementTypeName}>();");
        sb.AppendLine($"{indent}    reader.ReadStartArray();");
        sb.AppendLine($"{indent}    while (reader.Read())");
        sb.AppendLine($"{indent}    {{");

        var isElementNullable = elementType.IsNullable;
        var underlyingElementType = elementType.NullableUnderlyingType ?? elementType;

        if (isElementNullable || !elementType.IsValueType)
        {
            sb.AppendLine($"{indent}        if (reader.CurrentType == BsonType.Null)");
            sb.AppendLine($"{indent}            list.Add(default!);");
            sb.AppendLine($"{indent}        else");
            GenerateReadArrayElement(sb, underlyingElementType, indent + "            ");
        }
        else
        {
            GenerateReadArrayElement(sb, underlyingElementType, indent + "        ");
        }

        sb.AppendLine($"{indent}    }}");
        sb.AppendLine($"{indent}    reader.ReadEndDocument();");
        sb.AppendLine($"{indent}    _{name} = list.ToArray();");
        sb.AppendLine($"{indent}}}");
    }

    private static void GenerateReadArrayElement(StringBuilder sb, TypeRefInfo type, string indent)
    {
        // Handle enums - read as underlying type and cast
        if (type.EnumUnderlyingType is { } enumUnderlying)
        {
            var typeName = type.FullyQualifiedName;
            if (enumUnderlying == SpecialType.System_Int64 || enumUnderlying == SpecialType.System_UInt64 || enumUnderlying == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}list.Add(({typeName})reader.ReadInt64());");
            }
            else
            {
                sb.AppendLine($"{indent}list.Add(({typeName})reader.ReadInt32());");
            }
            return;
        }

        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}list.Add(reader.ReadBoolean());");
                return;
            case SpecialType.System_Int32:
                sb.AppendLine($"{indent}list.Add(reader.ReadInt32());");
                return;
            case SpecialType.System_Int64:
                sb.AppendLine($"{indent}list.Add(reader.ReadInt64());");
                return;
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}list.Add(reader.ReadDouble());");
                return;
            case SpecialType.System_Single:
                sb.AppendLine($"{indent}list.Add((float)reader.ReadDouble());");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}list.Add(reader.ReadString());");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}list.Add(reader.ReadDateTime());");
                return;
        }

        if (type.FullyQualifiedName == "global::System.Guid" || type.Name == "Guid")
        {
            sb.AppendLine($"{indent}list.Add(reader.ReadGuid());");
            return;
        }

        // Nested object (but not primitives)
        if (type.NestedTypeInfo is { } nestedType)
        {
            var methodName = GetSafeMethodName(nestedType);
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    reader.ReadStartNestedDocument();");
            sb.AppendLine($"{indent}    list.Add(Read{methodName}Inner(reader));");
            sb.AppendLine($"{indent}    reader.ReadEndDocument();");
            sb.AppendLine($"{indent}}}");
        }
    }

    private static void GenerateReadValue(StringBuilder sb, string name, TypeRefInfo type, string indent)
    {
        // Handle enums - read as underlying type and cast
        if (type.EnumUnderlyingType is { } enumUnderlying)
        {
            var typeName = type.FullyQualifiedName;
            if (enumUnderlying == SpecialType.System_Int64 || enumUnderlying == SpecialType.System_UInt64 || enumUnderlying == SpecialType.System_UInt32)
            {
                sb.AppendLine($"{indent}_{name} = ({typeName})reader.ReadInt64();");
            }
            else
            {
                sb.AppendLine($"{indent}_{name} = ({typeName})reader.ReadInt32();");
            }
            return;
        }

        switch (type.SpecialType)
        {
            case SpecialType.System_Boolean:
                sb.AppendLine($"{indent}_{name} = reader.ReadBoolean();");
                return;
            case SpecialType.System_Int32:
            case SpecialType.System_Byte:
            case SpecialType.System_SByte:
            case SpecialType.System_Int16:
            case SpecialType.System_UInt16:
                sb.AppendLine($"{indent}_{name} = reader.ReadInt32();");
                return;
            case SpecialType.System_Int64:
            case SpecialType.System_UInt32:
            case SpecialType.System_UInt64:
                sb.AppendLine($"{indent}_{name} = reader.ReadInt64();");
                return;
            case SpecialType.System_Single:
                sb.AppendLine($"{indent}_{name} = (float)reader.ReadDouble();");
                return;
            case SpecialType.System_Double:
                sb.AppendLine($"{indent}_{name} = reader.ReadDouble();");
                return;
            case SpecialType.System_String:
                sb.AppendLine($"{indent}_{name} = reader.ReadString();");
                return;
            case SpecialType.System_DateTime:
                sb.AppendLine($"{indent}_{name} = reader.ReadDateTime();");
                return;
        }

        if (type.FullyQualifiedName == "global::System.Guid" || type.Name == "Guid")
        {
            sb.AppendLine($"{indent}_{name} = reader.ReadGuid();");
            return;
        }

        // Nested object (but not primitives)
        if (type.NestedTypeInfo is { } nestedType)
        {
            var methodName = GetSafeMethodName(nestedType);
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    reader.ReadStartNestedDocument();");
            sb.AppendLine($"{indent}    _{name} = Read{methodName}Inner(reader);");
            sb.AppendLine($"{indent}    reader.ReadEndDocument();");
            sb.AppendLine($"{indent}}}");
        }
    }

    private static void GenerateSerializeMethod(StringBuilder sb, EquatableList<TypeInfo> types)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Serializes the specified object to BSON format.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public void Serialize(object input, Stream output)");
        sb.AppendLine("    {");
        sb.AppendLine("        using var writer = new BsonWriter(output, leaveOpen: true);");
        sb.AppendLine("        var inputType = input.GetType();");

        var first = true;
        foreach (var type in types)
        {
            var typeName = type.FullyQualifiedName;
            var methodName = GetSafeMethodName(type);
            
            if (first)
            {
                sb.AppendLine($"        if (inputType == typeof({typeName}))");
                first = false;
            }
            else
            {
                sb.AppendLine($"        else if (inputType == typeof({typeName}))");
            }
            
            sb.AppendLine($"            Write{methodName}(writer, ({typeName})input);");
        }

        sb.AppendLine("        else");
        sb.AppendLine("            throw new NotSupportedException($\"Type {input.GetType()} is not supported for serialization.\");");
        sb.AppendLine("    }");
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, EquatableList<TypeInfo> types)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Deserializes BSON data to an object of the specified type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public object? Deserialize(Stream input, Type type)");
        sb.AppendLine("    {");
        sb.AppendLine("        using var reader = new BsonReader(input, leaveOpen: true);");

        var first = true;
        foreach (var type in types)
        {
            var typeName = type.FullyQualifiedName;
            var methodName = GetSafeMethodName(type);

            if (first)
            {
                sb.AppendLine($"        if (type == typeof({typeName}))");
                first = false;
            }
            else
            {
                sb.AppendLine($"        else if (type == typeof({typeName}))");
            }

            sb.AppendLine($"            return Read{methodName}(reader);");
        }

        sb.AppendLine();
        sb.AppendLine("        throw new NotSupportedException($\"Type {type} is not supported for deserialization.\");");
        sb.AppendLine("    }");
    }

    private static IEnumerable<IPropertySymbol> GetAllProperties(INamedTypeSymbol type)
    {
        // Collect types from derived to base
        var typeHierarchy = new List<INamedTypeSymbol>();
        var currentType = type;
        
        while (currentType != null && currentType.SpecialType != SpecialType.System_Object)
        {
            typeHierarchy.Add(currentType);
            currentType = currentType.BaseType;
        }
        
        // Process in derived-to-base order (no reversal)
        // This means properties from the most derived class come first
        var properties = new List<IPropertySymbol>();
        var seenPropertyNames = new HashSet<string>();
        
        foreach (var typeInHierarchy in typeHierarchy)
        {
            foreach (var member in typeInHierarchy.GetMembers())
            {
                if (member is IPropertySymbol property &&
                    property.DeclaredAccessibility == Accessibility.Public &&
                    !property.IsStatic &&
                    property.GetMethod != null)
                {
                    // Only add if not already added (handles property hiding/new)
                    if (seenPropertyNames.Add(property.Name))
                    {
                        properties.Add(property);
                    }
                }
            }
        }
        
        return properties;
    }

    private static string GetSafeMethodName(TypeInfo type)
    {
        // Create a safe method name from the type name
        return type.Name.Replace(".", "_").Replace("+", "_");
    }

    private static TypeInfo ExtractTypeInfo(INamedTypeSymbol symbol, HashSet<INamedTypeSymbol>? visited = null)
    {
        visited ??= new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        if (!visited.Add(symbol))
            return new TypeInfo(
                symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                symbol.Name,
                false,
                symbol.IsValueType,
                EquatableList<PropertyInfo>.Empty);

        var properties = GetAllProperties(symbol)
            .Select(p => new PropertyInfo(p.Name, ExtractTypeRefInfo(p.Type, visited)))
            .ToList();

        return new TypeInfo(
            symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            symbol.Name,
            symbol.IsRecord && symbol.TypeKind == TypeKind.Class,
            symbol.IsValueType,
            new EquatableList<PropertyInfo>(properties));
    }

    private static TypeRefInfo ExtractTypeRefInfo(ITypeSymbol symbol, HashSet<INamedTypeSymbol> visited)
    {
        var isNullableValueType = symbol is INamedTypeSymbol { IsGenericType: true } nt &&
                                  nt.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;
        var isNullable = isNullableValueType || symbol.NullableAnnotation == NullableAnnotation.Annotated;

        TypeRefInfo? nullableUnderlying = null;
        if (isNullableValueType && symbol is INamedTypeSymbol nvt)
        {
            nullableUnderlying = ExtractTypeRefInfo(nvt.TypeArguments[0], visited);
        }

        TypeRefInfo? arrayElement = null;
        if (symbol is IArrayTypeSymbol arrayType)
        {
            arrayElement = ExtractTypeRefInfo(arrayType.ElementType, visited);
        }

        SpecialType? enumUnderlying = null;
        if (symbol.TypeKind == TypeKind.Enum && symbol is INamedTypeSymbol enumType)
        {
            enumUnderlying = enumType.EnumUnderlyingType?.SpecialType;
        }

        TypeInfo? nestedTypeInfo = null;
        if (symbol is INamedTypeSymbol namedType && 
            !IsPrimitiveType(symbol) && 
            symbol is not IArrayTypeSymbol &&
            !isNullableValueType)
        {
            nestedTypeInfo = ExtractTypeInfo(namedType, visited);
        }

        return new TypeRefInfo(
            symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            symbol is INamedTypeSymbol ns ? ns.Name : symbol.Name,
            symbol.SpecialType,
            symbol.IsValueType,
            isNullable,
            symbol.NullableAnnotation,
            symbol.TypeKind,
            enumUnderlying,
            arrayElement,
            nullableUnderlying,
            nestedTypeInfo);
    }
}
